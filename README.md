# battleship

> Mitty APCS A Battleship implementation in JavaFX

# Server API Documentation
The server works by using a websocket protocol, which is currently hosted on `wss://simfony.tech/mitty/websocket`. In some ways, querying from the server is similar to accessing a GraphQL endpoint; there is only one route to access.

To query data, send a (stringified) JSON object with the query parameters.
```json
{
  "option": "new", // example
  ...
}
```

## Create New Game
To create a new game, send `"option": "new"` in the JSON object.

## Join Game
To join a game (after the game code has been generated by another player), send this data in the JSON object:

```json
{
  "option": "join",
  "matchId": "myMatchId", // generated after creating a new game
}
```

## Ready
To indicate that a player is ready, send `"option": "ready"` in the JSON object.

## Make a Move
To make a move, send the following data in the JSON object. See [Making a Move](#making-a-move) for constraint details.

The following makes a move on square A4
```json
{
  "option": "move",
  "col": "a", // example
  "row": 4, // example
}
```

## Game Lifecycle
If the other player disconnects from the websocket connection, the server deletes the game and sends a string `"The other player has disconnected"` to the other player.

---

# Java Client API Documentation

## Development Environment
Build the `jar` file with dependencies by running the following in the shell (NOTE: a build of Gradle is required). After cloning this repo, run the following starting at the root of the repo file tree:
```sh
cd lib && chmod +x ./gradlew # cd and set execution permissions on script
./gradlew shadowJar # compiles and builds a fat JAR
```

If you have a build of the project, just take the JAR file and ignore the above step.

## Setup
The Battleship client will be instantiated as `app` for the purposes of this documentation.

In your driver class, implement the `BattleshipInterface` interface, which will give access to the [lifecycle hooks](#lifecycle-hooks-event-listening).

To run your client successfully, make sure to implement all the methods in the interface to conform to the interface.

In your main method, instantiate a class of your client that conforms to the BattleshipInterface (this will allow the lifecycle hooks to connect between the API and your client).

Then, pass that client instance into the constructor of `Battleship`, which will create a new Battleship application and provide the client with access to the Client API.

Here is an example
```java title=MyClient.java
public class MyClient implements BattleshipInterface {
  // implement the methods of the interface
  public void matchJoined(String matchId){}
  public void receivedMove(char col, int row){}
  public void gameDestroyed(){}
  // handle your own logic

  public static void main(String[] args) {
    MyClient c = new MyClient();
    Battleship app = new Battleship(c);
    // can now use the API!
  }
}
```


## Create Game
The Create Game API generates a new game and a game code for the game creator to send to the second player.

The method `app.createNewGame()` creates a new game and returns the game code of the newly created game if run successfully.

This code creates a new game and outputs the game code to the console.
```java
System.out.println(app.createNewGame());
```

## Join Game
The Join Game API allows the second player to join the game created by the first player.

Call `app.joinGame(code)` with `code`, a `String` containing the game code created by another player by `app.createGame()`. The method, if run successfully, will return the game code as confirmation.

This code joins the new game and outputs the game code as confirmation to the console.
```java
String code = "6da5a0cd-1668-46a2-8a52-ad92fe0e4bb0"; // sample code generated by createNewGame()
System.out.println(app.joinGame(code));
```

## Game Ready
The Game Ready API allows each player to confirm that he or she has placed all the battleships and is ready to start a game.

Each player must call the method `app.setReady(code)`. Pass `code`, a `String` with the game code. This method will return the game code as confirmation if run successfully.

This code joins the new game and outputs the game code as confirmation to the console.
```java
String code = "6da5a0cd-1668-46a2-8a52-ad92fe0e4bb0"; // sample code generated by createNewGame()
System.out.println(app.setReady(code));
```

## Making a Move
The Make Move API allows each player To make a move, selecting the column (A-J) and row (0-9) of the desired target.

The player who takes the current turn calls `app.makeMove(col, row)`, where `col` is a `char` in the set `a-j, A-J`, and `row` is an `int` from `0-9`. Together, these values specify the coordinates of the target on the Battleship board.

This method, if run successfully, will wait for the other player to make his or her move before sending back the move that the other player has made.

## Lifecycle Hooks (Event Listening)
The Battleship Client API uses a custom interface to handle "lifecycle hooks" that trigger when certain events occur (for example when the game is destroyed). As your client will implement this interface, `BattleshipInterface`, it is critical that you implement all the methods in the interface inside your class with logic to handle what happens when these events occur.
### Game Destroyed
`public void gameDestroyed()` inside the `BattleshipInterface` is called when one client disconnects from the game. In this case, the server destroys the game, and it is up to the client to implement the logic of `gameDestroyed()`.
### Move Received
`public void receivedMove(char col, int row)` runs when the other player has sent through his or her move successfully. It contains the coordinates of the other player's move. Implement this method to update the game state of your client.
### Match Joined
`public void matchJoined(String matchId)` runs when the other player has joined a game with the game code that Player 1 has created.